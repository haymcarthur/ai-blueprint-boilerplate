#!/usr/bin/env node

/**
 * Bootstrap Script
 * Generates code from Figma exports
 *
 * Usage: npm run bootstrap
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { execSync } from 'child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.join(__dirname, '..');

// Colors for terminal output
const colors = {
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  blue: '\x1b[34m',
  reset: '\x1b[0m',
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function logSuccess(message) {
  log(`âœ“ ${message}`, 'green');
}

function logWarning(message) {
  log(`âš ï¸  ${message}`, 'yellow');
}

function logError(message) {
  log(`âœ— ${message}`, 'red');
}

function logInfo(message) {
  log(`â„¹ ${message}`, 'blue');
}

// Check if file exists
function fileExists(filePath) {
  return fs.existsSync(filePath);
}

// Read JSON file
function readJSON(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf-8');
    return JSON.parse(content);
  } catch (error) {
    logError(`Failed to read ${filePath}: ${error.message}`);
    process.exit(1);
  }
}

// Write file
function writeFile(filePath, content) {
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  fs.writeFileSync(filePath, content, 'utf-8');
}

// Generate tokens from design-tokens.json
function generateTokens(tokensData) {
  logInfo('Generating token files...');

  // Generate colors.ts
  const colorsContent = `/**
 * Color Tokens
 * Generated from design-tokens.json
 * DO NOT EDIT: This file is auto-generated by the bootstrap script
 */

export const colors = {
${tokensData.colors.map(token => `  '${token.name}': '${token.value}',`).join('\n')}
} as const;

export type ColorToken = keyof typeof colors;
`;
  writeFile(path.join(rootDir, 'src/tokens/colors.ts'), colorsContent);
  logSuccess(`Generated src/tokens/colors.ts (${tokensData.colors.length} tokens)`);

  // Generate typography.ts
  const typographyContent = `/**
 * Typography Tokens
 * Generated from design-tokens.json
 * DO NOT EDIT: This file is auto-generated by the bootstrap script
 */

export const typography = {
${tokensData.typography.map(token => `  '${token.name}': {
    fontFamily: '${token.fontFamily}',
    fontSize: '${token.fontSize}',
    fontWeight: ${token.fontWeight},
    lineHeight: '${token.lineHeight}',
  },`).join('\n')}
} as const;

export type TypographyToken = keyof typeof typography;
`;
  writeFile(path.join(rootDir, 'src/tokens/typography.ts'), typographyContent);
  logSuccess(`Generated src/tokens/typography.ts (${tokensData.typography.length} tokens)`);

  // Generate spacing.ts
  const spacingTokens = tokensData.spacing || [];
  const spacingContent = `/**
 * Spacing Tokens
 * Generated from design-tokens.json
 * DO NOT EDIT: This file is auto-generated by the bootstrap script
 */

export const spacing = {
${spacingTokens.map(token => `  '${token.name}': '${token.value}',`).join('\n')}
} as const;

export type SpacingToken = keyof typeof spacing;
`;
  writeFile(path.join(rootDir, 'src/tokens/spacing.ts'), spacingContent);
  logSuccess(`Generated src/tokens/spacing.ts (${spacingTokens.length} tokens)`);

  // Generate effects.ts
  const effectsContent = `/**
 * Effect Tokens (Shadows, Blurs, etc.)
 * Generated from design-tokens.json
 * DO NOT EDIT: This file is auto-generated by the bootstrap script
 */

export const effects = {
${tokensData.effects.map(token => `  '${token.name}': '${token.value}',`).join('\n')}
} as const;

export type EffectToken = keyof typeof effects;
`;
  writeFile(path.join(rootDir, 'src/tokens/effects.ts'), effectsContent);
  logSuccess(`Generated src/tokens/effects.ts (${tokensData.effects.length} tokens)`);

  // Generate index.ts
  const indexContent = `/**
 * Design Tokens - Unified Export
 * Import from here for convenience
 */

export { colors, type ColorToken } from './colors';
export { typography, type TypographyToken } from './typography';
export { spacing, type SpacingToken } from './spacing';
export { effects, type EffectToken } from './effects';
`;
  writeFile(path.join(rootDir, 'src/tokens/index.ts'), indexContent);
  logSuccess('Generated src/tokens/index.ts');
}

// Generate component stub
function generateComponentStub(component) {
  const componentName = component.name;
  const componentDir = path.join(rootDir, 'src/components', componentName);

  // Generate props interface
  const props = component.props || [];
  const propsInterface = props.length > 0 ? props.map(prop => {
    if (prop.type === 'string' && prop.values) {
      return `  ${prop.name}?: ${prop.values.map(v => `'${v}'`).join(' | ')};`;
    } else if (prop.type === 'boolean') {
      return `  ${prop.name}?: boolean;`;
    } else if (prop.type === 'number') {
      return `  ${prop.name}?: number;`;
    } else {
      return `  ${prop.name}?: any;`;
    }
  }).join('\n') : '';

  const componentContent = `/**
 * ${componentName} Component
 * Generated from Figma export
 */

import { colors, spacing, typography } from '../../tokens';

interface ${componentName}Props {
${propsInterface}
  children?: React.ReactNode;
}

export const ${componentName} = ({
${props.map(prop => `  ${prop.name}${prop.defaultValue !== undefined ? ` = ${JSON.stringify(prop.defaultValue)}` : ''},`).join('\n')}
  children,
}: ${componentName}Props) => {
  // TODO: Implement ${componentName}
  // - Apply token-bound styles
  // - Implement variants
  // - Add event handlers

  return (
    <div>
      {children}
    </div>
  );
};
`;

  writeFile(path.join(componentDir, `${componentName}.tsx`), componentContent);

  // Generate index.ts
  const indexContent = `export { ${componentName} } from './${componentName}';
export type { ${componentName}Props } from './${componentName}';
`;
  writeFile(path.join(componentDir, 'index.ts'), indexContent);

  // Generate Storybook story
  const storyContent = `import type { Meta, StoryObj } from '@storybook/react';
import { ${componentName} } from './${componentName}';

const meta: Meta<typeof ${componentName}> = {
  title: 'Components/${componentName}',
  component: ${componentName},
  tags: ['autodocs', 'figma-component'],
${props.length > 0 ? `  argTypes: {
${props.map(prop => {
    if (prop.type === 'string' && prop.values) {
      return `    ${prop.name}: {
      control: 'select',
      options: [${prop.values.map(v => `'${v}'`).join(', ')}],
    },`;
    } else if (prop.type === 'boolean') {
      return `    ${prop.name}: {
      control: 'boolean',
    },`;
    } else {
      return `    ${prop.name}: {
      control: 'text',
    },`;
    }
  }).join('\n')}
  },` : ''}
};

export default meta;
type Story = StoryObj<typeof ${componentName}>;

export const Default: Story = {
  args: {
${props.map(prop => `    ${prop.name}: ${prop.defaultValue !== undefined ? JSON.stringify(prop.defaultValue) : 'undefined'},`).join('\n')}
    children: '${componentName} content',
  },
};
`;

  writeFile(path.join(componentDir, `${componentName}.stories.tsx`), storyContent);

  logSuccess(`Created src/components/${componentName}/`);
}

// Run plugin hooks
function runPluginHooks() {
  const hooksFile = path.join(rootDir, 'plugin-hooks.json');
  if (!fileExists(hooksFile)) {
    logWarning('plugin-hooks.json not found, skipping hooks');
    return;
  }

  const hooks = readJSON(hooksFile);
  const bootstrapHooks = hooks.hooks?.onBootstrapExport?.commands || [];

  if (bootstrapHooks.length === 0) {
    return;
  }

  logInfo('Running post-bootstrap hooks...');
  for (const command of bootstrapHooks) {
    try {
      logInfo(`Running: ${command}`);
      execSync(command, { cwd: rootDir, stdio: 'inherit' });
      logSuccess(`Completed: ${command}`);
    } catch (error) {
      logWarning(`Failed: ${command} (${error.message})`);
    }
  }
}

// Main bootstrap function
async function bootstrap() {
  log('\nðŸš€ AI Blueprint Bootstrap\n', 'blue');

  // Check if exports exist
  const catalogFile = path.join(rootDir, 'component-catalog.json');
  const tokensFile = path.join(rootDir, 'design-tokens.json');

  if (!fileExists(catalogFile)) {
    logError('component-catalog.json not found in project root');
    logInfo('Run Figma export first and save files to project root');
    process.exit(1);
  }

  if (!fileExists(tokensFile)) {
    logError('design-tokens.json not found in project root');
    logInfo('Run Figma export first and save files to project root');
    process.exit(1);
  }

  // Read exports
  logInfo('Reading Figma exports...');
  const catalog = readJSON(catalogFile);
  const tokens = readJSON(tokensFile);

  // Generate tokens
  generateTokens(tokens);

  // Generate components
  logInfo('\nGenerating component stubs...');
  const components = catalog.components || [];
  for (const component of components) {
    generateComponentStub(component);
  }

  // Update naming registry (stub - real implementation would be more complex)
  logInfo('\nUpdating naming registry...');
  const namingRegistry = {
    version: '1.0.0',
    aliases: components.map(c => ({
      figmaName: c.name,
      codeName: c.name,
      description: `${c.name} component`,
    })),
    rules: [],
  };
  writeFile(
    path.join(rootDir, 'naming-registry.json'),
    JSON.stringify(namingRegistry, null, 2)
  );
  logSuccess('Updated naming-registry.json');

  // Run hooks
  log('\n', 'reset');
  runPluginHooks();

  // Success summary
  log('\nâœ… Bootstrap complete!\n', 'green');
  log('Next steps:', 'blue');
  log('1. Implement components in src/components/', 'reset');
  log('2. Start Storybook: npm run storybook', 'reset');
  log('3. Test components and get designer approval', 'reset');
  log('\n', 'reset');
}

// Run bootstrap
bootstrap().catch((error) => {
  logError(`Bootstrap failed: ${error.message}`);
  process.exit(1);
});
